# 排序算法学习

## 简单排序算法的下界

逆序:数据中，具有性质i<j,但a[i]>a[j]的序偶(a[i],a[j]).

而一个已排序的数组是没有逆序的。逆序数恰好是一个插入排序执行的交换次数。

1.定理: N个互异数的数据的平均逆序数N(N-1)/4

 证明: 对于元素的任意列表L，例如 (2,26,31,27)假设其反序列表为Lr,(27,31,26,2).那么对于任意序偶((x,y),y<x).显然该序偶是一个逆序，且必然是L或Lr中的一个逆序。因此，

​    L和Lr中逆序集合是一个常量，其值等于一个完全逆序的列表,对于L和Lr其完全逆序的列表纪为La,则La为

(32,27,26,2),则其逆序数为

$$
S(La) = 3 +2+1+0;  ==>[(32,27),(32,26),(32,2)]   +[(27,26),(27,2)] + [(26,2)]
$$


推广至N个数，则:

$$
S[Ln] = (n-1)+(n-2)+..+(n-(n-1))+(n-n
$$


又可记为:

$$
S[Ln] = (n-n)+(n-(n-1))+...+(n-2)+(n-1)
$$


两者相加:

$$
 2S[Ln] = (n-1)+(n-1)+...+(n-1)+(n-1) 
$$

$$
==>S[Ln] = \frac{n(n-1)}{2}
$$
`由于，该和为全逆序排序所得，一个平均下来，一般表列拥有该量的一半，即:
$$
S[Ln] = \frac{n(n-1)}{4}
$$


​          定理: 通过交换相邻元素进行排序的任何算法，其时间复杂度平均都需要:
$$
\Omega(N^2)
$$


   证:初始的平均逆序数为$  N(N-1)/4 = \Omega(N^2) $ ,而每次交换只减少一个逆序，因此需要$ \Omega(N^2) $次交换

该定理对插入排序，冒泡排序，选择排序等一整类只进行相邻匀速的交换的排序算法都适用。



## 插入排序

插入排序就像打牌是插牌样，第P次插牌时保障从位置0到p-1都是已排序的状态。其时间复杂度由上面的<a href="#简单排序算法的下界">简单排序算法的下界</a>可知为$  \Omega(N^2) $,可计算一下其算法上界，完全逆序的情况就是插牌排序最坏的情况，例:

 Ln = N,N-1,...3,2,1

排序时，第一个元素默认为已排序的，无需参与比较交换。从N-1开始，需要比较交换，很容易得出，对于N-1是比较交换一次，N-2是2次，..到了数字1时，由于前面的数都比它大，需要比较N-1次，则:
$$
S[Ln] = 1+2+3+...+(n-1)
$$
又可记为:
$$
S[Ln] = (n-1)+(n-2)+..+1
$$

两者相加后除，可得:
$$
S[Ln] = \frac{n(n-1)}{2}
$$
所以其时间复杂度为$ \Omega(N^2) $


```java
public class InsertionSort implements Sort {
    @Override
    public  <T extends  Comparable> T[] sort(T[] waitSort) {
        if(Objects.isNull(waitSort)|| waitSort.length<=0){
           return  null;
        }
       int temporary_coordinate;
        //插入排序中假设数组的第一个是有序的
        for (int wait_insert_sort_value_coordinate =1;wait_insert_sort_value_coordinate < waitSort.length;
             wait_insert_sort_value_coordinate++) {
            //待插入值
           T  wait_insert_sort_value = waitSort[wait_insert_sort_value_coordinate];
           //wait_insert_sort_value_coordinate与数组中在它坐标前的元素比较,若比之前元素值小，则递归找到其合适的位置
           for(temporary_coordinate = wait_insert_sort_value_coordinate;
               temporary_coordinate>0&& wait_insert_sort_value.compareTo(waitSort[temporary_coordinate-1])<0;
               temporary_coordinate--){
               T wait_go_forward_value =  waitSort[temporary_coordinate-1];
               waitSort[temporary_coordinate-1] = wait_insert_sort_value;
               waitSort[temporary_coordinate] = wait_go_forward_value;
           }

        }
        System.out.println("InsertionSort result:  "+Arrays.toString(waitSort));
        return waitSort;
    }
}

```



### 希尔排序

希尔排序是对插入排序的改进，改进点就是插入排序是每次这比较交换一个，而希尔排序每次对一块子数据集合进行排序。其会定义一个缩减增量hp,hm.hd...h1.保证h1为1,hp>hm>hd>..>h1.其思想就是，每次排序时，从待排序的数字集合中，分别抽1,1+hp,1+2hp...,最子集合进行排序。好处就是，在下次的hm排序时，抽样出的子集合会比hp时更接近有序。到h1时数据集合大多数是有序的。

例如对于数字集合:
 81,94,11,96,12,35,17,95,28,25
假设第一个增量为3，则上面集合会被分成以下3组
$$
 (81,96,17,25),(94,12,95),(11,35,28)
$$
然后对没组内使用插入排序进行交换排序，则小组排序后：
$$
(17,25,81,96),(12,94,95),(11,28,35)
$$
对应数组位置交换后，原列表为:
$$
17,12,11,25,94,28,81,95,35,96
$$

如此往复。

其时间负责度，最坏情况是$ \Omega(N^2) $,改进相关增量序列后可以突破这个，对于Hibbard增量希尔排序性能能达到$ \Omega(N^ \frac {3}{2} ) $

证明最坏情况是$ \Omega(N^2) $

首先我们得找到一个最坏的情形，设有一数列为N,我们设定增量都是偶数，那么当它偶数位置有N/2的在每次增量排序子集合都是最大且有序的数，在它奇数位置有N/2的在每次增量排序子集合都是最大且有序的数，例:
$$
1,9,2,10,3,11,4,12,5,13,6,14,7,15,8,16
$$
那么很显然，在增量为1前的增量都为偶数，且其子集合都是有序的因此不会排序，那么在增量为1时，很显然的，第i（i<=N/2）个最小的数，需要移动2i-1才能到达其应该的位置，由此有其N/2的最小元素恢复到正确位置需要:
$$
\sum_{i=1}^{N/2}i-1
$$
很显然是$ \Omega(N^2) $,至于Hibbard增量的证明，没看懂。。=_=|||

代码见:

```java

```



## 选择排序



